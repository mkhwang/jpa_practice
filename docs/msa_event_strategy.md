# MSA EVENT STRATEGY

- 이벤트 기반 시스템에서는 서비스 간에 데이터를 직접 주고받기보다는 이벤트(Event)라는 메시지를 통해 "무슨 일이 일어났는지"를 서로 알려준다. 
- 이때 이벤트 안에 어떤 데이터를 넣을지는 아키텍처의 효율성과 복잡도에 큰 영향을 준다
- 대표적인 4가지 이벤트 구성 방식인 **Zero-Payload, Selective Payload, Event-Carried State Transfer, Snapshot**에 대해 설명

---

## 1. Zero-Payload Event


- payload(실제 데이터)가 없는 이벤트
- 이벤트에는 그냥 "이 일이 일어났어"라는 정보만 담겨 있음.
- 어떤 데이터가 변경됐는지는 안 들어 있다.

### 예시

```json
{ "eventType": "UserUpdated", "userId": "1234" }
```

→ 이 이벤트는 "1234번 유저가 변경됨"이라는 신호만 보내고, 실제 유저 정보는 없음

### 특징

* 데이터는 안 보내고, ID만 보냄
* 수신자는 ID를 보고 데이터베이스나 다른 서비스에서 직접 조회해야 함

### 장단점

| 장점           | 단점             |
| ------------ | -------------- |
| 전송 용량 작음     | 데이터 조회 추가 필요   |
| 이벤트 구조 단순    | 실시간 데이터 반영 어려움 |
| 시스템 간 결합도 낮음 | 수신 로직 복잡도 증가   |

### 사용하면 좋은 상황

* 캐시 무효화 ("이거 바뀌었으니까 다시 조회해")
* 단순 트리거 ("이제 시작해")

---

## 2. Selective Payload Event

- 변경된 **일부 필드만** 포함해서 보내는 방식
- 전체 데이터를 보낼 필요 없이, 바뀐 부분만 알려줌

### 예시

```json
{ "eventType": "UserUpdated", "userId": "1234", "changedFields": { "nickname": "밍기" } }
```

→ 유저 전체 정보가 아니라, 바뀐 필드만 전송

### 특징

* 전송 데이터가 적지만 의미는 충분함
* 수신자가 어떤 필드가 바뀌었는지 명확히 알 수 있음

### 장단점

| 장점            | 단점                  |
| ------------- | ------------------- |
| 네트워크 부담 적음    | 데이터 간 의존성 처리 어려움    |
| 실시간 UI 갱신에 유리 | 전 상태를 모르기 때문에 비교 불가 |

### 사용하면 좋은 상황

* UI에서 바뀐 필드만 실시간으로 보여줘야 할 때
* 변경 기록(Log)을 간결하게 남기고 싶을 때

---

## 3. Event-Carried State Transfer (ECST)

- **전체 데이터를 통째로** 담아서 보내는 방식
- 수신자는 별도 조회 없이 이 이벤트 안의 정보만으로 상태를 반영할 수 있음

### 예시

```json
{ "eventType": "UserUpdated", "user": { "id": "1234", "name": "name", "nickname": "nickname" } }
```

→ 전체 유저 상태를 이벤트에 담아 전송합니다.

### 특징

* 조회가 필요 없음 (이벤트만으로 처리 가능)
* 데이터 정합성을 확보하기 좋음

### 장단점

| 장점            | 단점                           |
| ------------- | ---------------------------- |
| 수신자가 바로 처리 가능 | 메시지 크기 큼                     |
| 정합성 높음        | 브로커, 네트워크 부담 있음              |
| 이벤트만으로 재현 가능  | 모든 변경에 전체 데이터 보내는 건 낭비일 수 있음 |

### 사용하면 좋은 상황

* 여러 시스템에서 동일한 데이터를 복제할 때
* 검색용 인덱스(ElasticSearch 등) 동기화

---

## 4. Snapshot Event

- ECST처럼 전체 데이터를 담지만, **매번 보내는 게 아니라 주기적으로 캡처해서 전송**하는 방식

### 예시

* 매일 자정마다 "회원 상태 전체 스냅샷"을 보내는 이벤트

### 특징

* 이벤트 소싱에서 상태 복구용으로 자주 사용됨
* 실시간은 아니지만, 큰 흐름의 상태 동기화 가능

### 장단점

| 장점              | 단점             |
| --------------- | -------------- |
| 상태 복구에 유리       | 실시간성이 떨어짐      |
| 시스템 백업, 이중화에 좋음 | 불필요한 전송 가능성 있음 |

### 사용하면 좋은 상황

* 백업 용도, 복원 시점 확보
* 일정 주기 상태 동기화

---

## 4가지 방식 요약 비교표

| 항목       | Zero-Payload | Selective Payload | ECST         | Snapshot     |
| -------- | ------------ | ----------------- | ------------ | ------------ |
| 포함 데이터   | 없음           | 바뀐 필드만            | 전체 상태        | 전체 상태 (주기적)  |
| 추가 조회 필요 | 있음           | 경우에 따라 다름         | 없음           | 없음           |
| 메시지 크기   | 매우 작음        | 작음                | 큼            | 큼            |
| 정합성      | 낮음           | 보통                | 높음           | 높음           |
| 적합한 용도   | 트리거, 캐시 무효화  | 필드 변경 알림          | 데이터 복제, CQRS | 상태 백업, 재해 복구 |

---

## 마무리 요약

- 이벤트에 무엇을 담을지 결정하는 건 마이크로서비스 설계의 핵심
- 어떤 이벤트는 가볍고 빠르게, 어떤 이벤트는 정확하고 풍부하게 처리해야 할 수 있음
- **용도에 맞게 Zero / Selective / ECST / Snapshot을 조합해서 사용하는 것이 실무에서 가장 많이 쓰이는 방식**

> ✨ 핵심은 "이 이벤트를 받은 쪽이 어떤 액션을 할 수 있어야 하는가?"를 먼저 생각하는 것!
